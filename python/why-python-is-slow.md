# Python은 왜 느리게 설계됐는가

## 설계 철학

```
C (1972):      "프로그래머가 고생하면 컴퓨터가 편하다"
Python (1991): "컴퓨터가 고생하면 프로그래머가 편하다"
```

Python 창시자 귀도 반 로썸은 실행 속도보다 개발 속도를 우선했다.

## 느린 이유 = 편의 기능

| 느린 이유 | 대신 얻는 것 |
|---|---|
| PVM이 매번 해석 | 컴파일 없이 바로 실행 |
| 동적 타입 (`x = 1` → `x = "hi"` 가능) | 타입 선언 불필요 |
| 가비지 컬렉터 (자동 메모리 관리) | `malloc/free` 불필요 |
| 모든 것이 객체 | 유연한 코드 |

## C vs Python 코드 비교

```c
// C — 빠르지만 귀찮음
int x = 1;                        // 타입 직접 선언
int* p = malloc(sizeof(int));     // 메모리 직접 관리
free(p);                           // 직접 해제
```

```python
# Python — 느리지만 편함
x = 1              # 타입 알아서 판단
# 메모리? 알아서 관리됨
```

## 실행 경로 비교

```
C:      소스 → 기계어 → CPU          (직행)
Python: 소스 → 바이트코드 → PVM → CPU  (우회)
```

진짜 느린 이유는 단계가 많아서가 아니라, PVM → CPU 구간이 매 명령어마다 반복되기 때문.

## 그럼에도 Python이 성공한 이유

1991년 설계 판단: "컴퓨터 성능은 계속 올라가니까, 사람의 시간을 아끼는 게 더 가치 있다."

실제로 맞았다:
- 진입장벽이 낮아서 사람들이 빠르게 결과물을 만들 수 있었음
- AI/데이터/웹에서 1등 언어가 됨
- 무거운 연산은 C로 짠 numpy/tensorflow가 처리
- 크롤링 같은 I/O 작업은 네트워크 대기가 병목이라 언어 속도가 무의미

## JIT으로 개선 중

JavaScript V8은 자주 쓰는 바이트코드를 기계어로 바꿔서 PVM 해석 단계를 없앤다. Python 3.13부터 실험적 JIT이 도입되어 같은 방향으로 개선 중.